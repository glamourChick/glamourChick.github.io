<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LinkedList源码</title>
      <link href="/2019/08/07/linkedlist/"/>
      <url>/2019/08/07/linkedlist/</url>
      
        <content type="html"><![CDATA[<p>LinkedList是基于链表的数据结构。</p><p>public class LinkedList<e> extends AbstractSequentialList<e> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p><p><strong>继承：</strong><br>&emsp;&emsp;LinkedList 继承了AbstractSequentialList, 而AbstractSequentialList继承了AbstractList（ArrayList也继承它）, AbstractList支持随机访问，可以随意访问该数据结构中的任意一个节点，如vector可以通过[]操作符，直接访问[n]，不需要遍历其他的节点。<br>但是AbstractSequentialList仅支持按次序访问,要想访问第n个元素，只能从第一个开始,一个节点一个节点的往下找，因而随机访问效率低。</p><p><strong>接口：</strong><br>&emsp;&emsp;实现List接口：支持集合的一般操作。提供了相关的添加、删除、修改、遍历等功能。<br>&emsp;&emsp;实现Deque （Double ended queue）接口： 可用作队列或双端队列<br>&emsp;&emsp;实现Cloneable、Serializable接口：支持克隆和序列化。</p><p>LinkedList底层维护着双向链表，每个结点都有一个前驱和后继结点：<br>    private static class Node<e> {</e></p><pre><code>    E item; // 存储节点值    Node&lt;E&gt; next; // 后继，指向下一个节点    Node&lt;E&gt; prev; // 前驱，指向前一个节点    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}</code></pre><p><strong>LinkedList的成员变量：</strong><br> transient int size = 0; // LinkedList节点个数<br> transient Node<e> first;//头元素<br> transient Node<e> last;// 尾元素</e></e></p><p><strong>LinkedList的两种构造函数：</strong></p><pre><code>// 无参构造  public LinkedList() {} public LinkedList(Collection&lt;? extends E&gt; c) {    this();// 调用无参构造函数    addAll(c);// 添加集合中所有的元素}</code></pre><p>下面看下LinkedList的一些方法：</p><ol><li><a href="#f1">private void linkFirst(E e)// 表头添加元素</a></li><li><a href="#f2">void linkLast(E e)// 表尾添加元素</a></li><li><a href="#f3">public void addFirst(E e)// 调用linkFirst</a></li><li><a href="#f4">public void addLast(E e)// 调用linkLast</a></li><li><a href="#f5">void linkBefore(E e, Node<e> succ)// 在非空节点succ前插入节点e</e></a></li><li><a href="#f6">private E unlinkFirst(Node<e> f)//释放非空的首节点f，并返回值</e></a></li><li><a href="#f7">private E unlinkLast(Node<e> l)// 释放非空的尾节点l，并返回值</e></a></li><li><a href="#f8">public E removeFirst()// 从链表中移除头结点并返回其值</a></li><li><a href="#f9">public E removeLast()// 从链表中移除尾结点并返回其值</a></li><li><a href="#f10">E unlink(Node<e> x)// 释放非空节点x</e></a></li><li><a href="#f11">public E getFirst()//返回链表中的头结点的值</a></li><li><a href="#f12">public E getLast()//返回链表中尾结点的值，和上面的类似</a></li><li><a href="#f13">public int indexOf(Object o)//返回链表中参数第一次出现的索引位置，没有就返回-1</a></li><li><a href="#f14">public boolean contains(Object o)// 判断链表是否包含参数，包含为true</a></li><li><a href="#f15">public E remove(int index)//根据索引进行删除</a></li><li><a href="#f16">public boolean remove(Object o)//从列表中移除指定元素的第一个匹配项并返回true，如果列表不包含该参数，列表不变，返回false</a></li><li><a href="#f17">public boolean addAll(Collection&lt;? extends E&gt; c)// addAll有两种方法，一个传index,一个不传</a></li><li><a href="#f18">public boolean addAll(int index, Collection&lt;? extends E&gt; c)</a></li><li><a href="#f19">public void clear()//所有表中所有元素，此列表为空</a></li><li><a href="#f20">Node<e> node(int index)//返回指点索引的非空节点</e></a></li><li><a href="#f21">public E get(int index)//返回指定索引节点的值</a></li><li><a href="#f22">public E set(int index, E element)//替换指定位置节点的值，返回旧值</a></li><li><a href="#f23">public void add(int index, E element)// 指定位置新增节点</a></li><li><a href="#f24">public E peek()// 获取头节点的值</a></li><li><a href="#f25">public E poll()// 获取头节点的值，同时删除该头节点</a></li><li><a href="#f26">public void push(E e)//入栈</a></li><li><a href="#f27">public E pop()//出栈</a></li><li><a href="#f28">public Object[] toArray() //转为数组</a></li><li><a href="#f29">public <t> T[] toArray(T[] a)//转为数组，传入T类型的数组，返回T类型的数组</t></a></li></ol><p>// <span id="f1">表头添加元素</span><br>private void linkFirst(E e) {</p><pre><code>final Node&lt;E&gt; f = first;// 用一个常量存储旧的头结点final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);// 新建一个节点,节点值参数e,后继为旧的头节点first = newNode;// 设置newNode为新的头节点if (f == null)    last = newNode;// 如果newNode后面没有节点就将newNode作为最后一个节点else    f.prev = newNode;// 否则将旧的头节点前驱设置为newModesize++;// 长度增加modCount++;</code></pre><p>}</p><p>// <span id="f2">表尾添加元素</span><br>void linkLast(E e) {</p><pre><code>final Node&lt;E&gt; l = last;// 用一个常量存储旧的尾结点final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 新建一个节点,节点值参数e,前驱为旧的尾节点last = newNode;// 设置newNode为新的尾节点if (l == null)    first = newNode;// 如果newNode前面没有节点就将newNode作为第一个节点else    l.next = newNode;// 否则旧的尾结点后继设置为newModesize++;// 长度增加modCount++;</code></pre><p>}</p><p>//<span id="f3">调用linkFirst</span><br>public void addFirst(E e) {<br>&emsp;&emsp;linkFirst(e);<br>}<br>//<span id="f4">调用linkLast</span><br>public void addLast(E e) {<br>&emsp;&emsp;linkLast(e);<br>}</p><p>// <span id="f5">在非空节点succ前插入节点e</span><br>void linkBefore(E e, Node<e> succ) {</e></p><pre><code>final Node&lt;E&gt; pred = succ.prev;// 常量pred 存储 succ的前驱final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);// 新建node, 前驱为pred, 后继为succ, 值为esucc.prev = newNode;// 将succ的前驱设置为newNodeif (pred == null)    first = newNode;// 如果pred为null,则表明原succ为头节点，设置newNoode为头节点else    pred.next = newNode;// 否则设置pred的后继为newNodesize++;// 长度增加modCount++;</code></pre><p>}</p><p>//<span id="f6">释放非空的首节点f，并返回值</span><br>private E unlinkFirst(Node<e> f) {</e></p><pre><code>final E element = f.item;// 常量element存f的值final Node&lt;E&gt; next = f.next;// 常量节点next 存f的后继f.item = null;// f节点的值设置为nullf.next = null;// 切断f与后继节点的关联first = next;// 头节点改为f的后继节点if (next == null)    last = null;//如果f后继节点为null,说明该表只有一个元素，f既是头节点，也是尾结点，f将要被移除，所以last也要设置为nullelse    next.prev = null;//否则，将新的头节点前驱设置为nullsize--;modCount++;return element;// 返回被释放的节点的值</code></pre><p>}</p><p>// <span id="f7">释放非空的尾节点l，并返回值</span><br>private E unlinkLast(Node<e> l) {</e></p><pre><code>final E element = l.item;// 常量element存l的值final Node&lt;E&gt; prev = l.prev;// 常量节点prev 存l的前驱l.item = null;// 清除l节点的值l.prev = null; // 切断l与前驱节点的关联last = prev;// 尾节点改为l的前驱节点if (prev == null)    first = null;//如果l前驱节点为null，说明该表只有一个元素，l既是头节点，也是尾结点，l将要被移除，所以last也要设置为nullelse    prev.next = null;//否则，将新的尾节点后继设置为nullsize--;modCount++;return element;// 返回被释放的节点的值</code></pre><p>}</p><p>// <span id="f8">从链表中移除头结点并返回其值</span><br>public E removeFirst() {</p><pre><code>final Node&lt;E&gt; f = first;if (f == null)    throw new NoSuchElementException();return unlinkFirst(f);// 调用了unlinkFirst方法</code></pre><p>}<br>// <span id="f9">从链表中移除尾结点并返回其值</span><br>public E removeLast() {</p><pre><code>final Node&lt;E&gt; l = last;if (l == null)    throw new NoSuchElementException();return unlinkLast(l);</code></pre><p>}</p><p>// <span id="f10">释放非空节点x</span><br>E unlink(Node<e> x) {</e></p><pre><code>//保存 x的值、前驱、后继final E element = x.item;final Node&lt;E&gt; next = x.next;final Node&lt;E&gt; prev = x.prev; if (prev == null) {    first = next; // 如果x前驱为空，则x为头结点，设置x的下一个节点为first} else {    prev.next = next;// 否则设置x上一个节点的后继为x下一个节点    x.prev = null;// 并且设置x的前驱为null}if (next == null) {    last = prev;// 如果x后继为空，则表明x为尾节点，将x的前一个节点设置为last} else {    next.prev = prev;// 否则 x下一个节点的前驱设置为x的上一个节点    x.next = null;// 并把x的后继置null}//此时的x就是个孤家寡人，它的前驱后继都为null，它的上下节点进行了关联。接着再处理x的值x.item = null;// x的值置nullsize--;//链表长度减1modCount++;return element;// 返回删除的节点</code></pre><p>}</p><p>//<span id="f11">返回链表中的头结点的值</span><br>public E getFirst() {</p><pre><code>final Node&lt;E&gt; f = first;if (f == null)    throw new NoSuchElementException();//如果不存在，则抛异常return f.item;</code></pre><p>}</p><p>//<span id="f12">返回链表中尾结点的值，和上面的类似</span><br>public E getLast() {</p><pre><code>final Node&lt;E&gt; l = last;if (l == null)    throw new NoSuchElementException();return l.item;</code></pre><p>}</p><p>//<span id="f13">返回链表中参数第一次出现的索引位置，没有就返回-1</span><br>public int indexOf(Object o) {</p><pre><code>int index = 0;//如果参数o为null,则返回值为null的节点的索引//o不为null，则返回值与o相匹配的节点的索引// 如没匹配到则返回-1if (o == null) {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (x.item == null)            return index;        index++;    }} else {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (o.equals(x.item))            return index;        index++;    }}return -1;</code></pre><p>}<br>// <span id="f14">判断链表是否包含参数，包含为true</span><br>public boolean contains(Object o) {<br>&emsp;&emsp;return indexOf(o) != -1;<br>}</p><p>//<span id="f15">根据索引进行删除</span><br>public E remove(int index) {</p><pre><code>checkElementIndex(index);return unlink(node(index));</code></pre><p>}<br>//<span id="f16">从列表中移除指定元素的第一个匹配项并返回true，如果列表不包含该参数，列表不变，返回false</span><br>public boolean remove(Object o) {</p><pre><code>if (o == null) {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (x.item == null) {            unlink(x);            return true;        }    }} else {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (o.equals(x.item)) {            unlink(x);            return true;        }    }}return false;</code></pre><p>}<br>// <span id="f17">addAll有两种方法，一个传index,一个不传</span><br>public boolean addAll(Collection&lt;? extends E&gt; c) {<br>&emsp;&emsp;return addAll(size, c);<br>}<br><span id="f18">不传index</span><br>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {</p><pre><code>checkPositionIndex(index);// 判断index是否越界，越界则抛出异常，0 &lt;= index &lt;= sizeObject[] a = c.toArray(); // 将集合参数c转为数组int numNew = a.length;// 获取其长度if (numNew == 0)    return false;//如果传进来的数组没有值，则返回falseNode&lt;E&gt; pred, succ; //新建前驱后继节点，前驱：precursor,后继: succeedif (index == size) {//若在表尾添加,则前驱为原尾结点，后继为null    succ = null;    pred = last;} else { //否则，前驱为index上一个节点,后继为index节点    succ = node(index);    pred = succ.prev;}//循环插入参数集合元素for (Object o : a) {    @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;    //新建一个有前驱和值的节点，此时newNode的前一个节点确定了，但是newNode前一个节点还未设置后继    Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);    if (pred == null)        first = newNode;// 前驱pred为null，表明在头节点前插入，设置newNode为新的头节点    else        pred.next = newNode;//否则设置pred的后继为当前节点，即newNode前一个节点设置了后继    pred = newNode;//newNode作为下一个节点的前驱}//在经过上面的循环后，此时pred=newNode，参数集合的头部已经连接进原链表中，但是尾部还没有连接进原链表中if (succ == null) {    last = pred;// 如果在表尾插入，则设置newNode为尾结点} else {//否则 newNode的后继设置为succ，并吧succ的前驱设置为newNode,这样参数集合的尾部也连接进原链表中    pred.next = succ;    succ.prev = pred;}size += numNew;//长度增加 numNewmodCount++;return true;</code></pre><p>}</p><p>//<span id="f19">所有表中所有元素，此列表为空</span><br>public void clear() {</p><pre><code>//从first节点开始，依次清空每个节点。//x不在for()中设置为next,而是在循环体中设置为next,是因为方法体执行完后，x.next=null了for (Node&lt;E&gt; x = first; x != null; ) {    Node&lt;E&gt; next = x.next;    x.item = null;    x.next = null;    x.prev = null;    x = next; }//头尾节点设置为nullfirst = last = null;size = 0;modCount++;</code></pre><p>}<br>//<span id="f20">返回指点索引的非空节点</span><br>Node<e> node(int index) {</e></p><pre><code>//此处查询进行了优化，每次只要查询列表的一半//size右移1位，变为size的一半，在列表的前半段查询if (index &lt; (size &gt;&gt; 1)) {    Node&lt;E&gt; x = first;    for (int i = 0; i &lt; index; i++)        x = x.next;    return x;} else {//在列表的后半段查询    Node&lt;E&gt; x = last;    for (int i = size - 1; i &gt; index; i--)        x = x.prev;    return x;}</code></pre><p>}<br>//<span id="f21">返回指定索引节点的值</span><br>public E get(int index) {</p><pre><code>checkElementIndex(index);//判断index是否越界，越界则抛出异常，0 &lt;= index &lt; sizereturn node(index).item;</code></pre><p>}</p><p>//<span id="f22">替换指定位置节点的值，返回旧值</span><br>public E set(int index, E element) {</p><pre><code>checkElementIndex(index);Node&lt;E&gt; x = node(index);//获取index位置的节点E oldVal = x.item;x.item = element;//值更替return oldVal;</code></pre><p>}<br>// <span id="f23">指定位置新增节点</span><br>public void add(int index, E element) {</p><pre><code>checkPositionIndex(index);if (index == size)//在表尾添加    linkLast(element);else    linkBefore(element, node(index));//在index节点前添加</code></pre><p>}<br>// <span id="f24">获取头节点的值</span><br>public E peek() {</p><pre><code>final Node&lt;E&gt; f = first;return (f == null) ? null : f.item;</code></pre><p>}<br>// <span id="f25">获取头节点的值，同时删除该头节点</span><br>public E poll() {</p><pre><code>final Node&lt;E&gt; f = first;return (f == null) ? null : unlinkFirst(f);</code></pre><p>}<br>//<span id="f26">入栈</span><br>public void push(E e) {<br>&emsp;&emsp;addFirst(e);<br>}<br>//<span id="f27">出栈</span><br>public E pop() {<br>&emsp;&emsp;return removeFirst();<br>}<br>//<span id="f28">转为数组，就是新建个数组，然后把链表中值一个个加到数组中，返回的是Object类型数组</span><br>public Object[] toArray() {</p><pre><code>Object[] result = new Object[size];int i = 0;for (Node&lt;E&gt; x = first; x != null; x = x.next)    result[i++] = x.item;return result;</code></pre><p>}<br>//<span id="f29">转为数组，传入T类型的数组，返回T类型的数组</span><br>public <t> T[] toArray(T[] a) {</t></p><pre><code>// 如果传入的a比链表小，则反射生成一个和链表一样大的数组if (a.length &lt; size)    a = (T[])java.lang.reflect.Array.newInstance(                        a.getClass().getComponentType(), size);int i = 0;Object[] result = a;for (Node&lt;E&gt; x = first; x != null; x = x.next)    result[i++] = x.item;//如果数组比链表大，则a[size]设为null, a[size]后的值不变if (a.length &gt; size)    a[size] = null;return a;</code></pre><p>}</p><p>linkedList中维护一个ListItr类，这个类实现了ListIterator，通过new LinkedList.listIterator()<br>或new LinkedList.listIterator(int index)来获取ListIterator迭代器,这里就不再讲了。</p><p>网上有人对LinkedList和ArrayList进行了一些实验，比较它们不同操作下的性能，大家可以看一看：<br><a href="https://blog.csdn.net/u011676300/article/details/80440774" target="_blank" rel="noopener">https://blog.csdn.net/u011676300/article/details/80440774</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java，linkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制习题</title>
      <link href="/2019/08/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/08/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在了解了类加载机制后，我们来点真格的！</p><h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><p>  public class  Father{</p><pre><code>static { System.out.println(&quot;Father静态代码块&quot;);}   { System.out.println(&quot;Father普通代码块&quot;); }   public Father() {       System.out.println(&quot;father 的构造函数&quot;);   }</code></pre><p>  }</p><p>  class Son extends  Father{</p><pre><code>static { System.out.println(&quot;son 静态代码块&quot;);}   { System.out.println(&quot;son 代码块&quot;); }   public Son() {      System.out.println(&quot;son 的构造函数&quot;);   }   public static void main(String[] args) {       System.out.println(&quot;son 的main方法&quot;);       new Son();   }</code></pre><p>  }</p><p><strong>输出结果：</strong><br>Father静态代码块<br>son 静态代码块<br>son 的main方法<br>Father普通代码块<br>father 的构造函数<br>son 代码块<br>son 的构造函数<br><strong>分析：</strong><br>&emsp;&emsp;实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法和对象初始化方法。<br>类初始化方法：编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。<br>对象初始化方法：编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</p><p>（我直接把上章的粘在这）<br>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：  </p><ol><li>创建类的实例时（new、反射、反序列化）;</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值;</li><li>调用类的静态方法;</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）;</li><li>初始化某个类的子类，则这个父类先被初始化;</li><li>Java虚拟机启动时被标明为启动类的类（包含main()方法的那个类），直接使用 java.exe命令来运行某个主类;</li></ol><p>&emsp;&emsp;首先，初始化有main方法的主类，即Son类，Son的父类还未初始化，所以先初始化Father类，输出：Father静态代码块和son 静态代码块。<br>&emsp;&emsp;然后，执行main方法中的输出：son 的main方法。<br>&emsp;&emsp;接着到了new Son()，进行对象初始化。还是先输出Father的对象初始化方法，按顺序为：Father普通代码块  father 的构造函数，接着输出Son的： son 代码块  son 的构造函数  </p><h3 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h3><p>  class Singleton{</p><pre><code>private static Singleton singleton = new Singleton();public static int value1;public static int value2 = 0;  static{ System.out.println(&quot;静态方法块&quot;);} private Singleton(){    value1++;    value2++;    System.out.println(&quot;构造方法&quot;);}{ System.out.println(&quot;普通方法块&quot;); }    public static Singleton getInstance(){       System.out.println(&quot;getInstance方法&quot;);       return singleton;   }   public static void main(String[] args) {       Singleton singleton = Singleton.getInstance();       System.out.println(&quot;Singleton value1:&quot; + singleton.value1);       System.out.println(&quot;Singleton value2:&quot; + singleton.value2);   }</code></pre><p>  }<br><strong>输出结果：</strong><br>普通方法块<br>构造方法<br>静态方法块<br>getInstance方法<br>Singleton value1:1<br>Singleton value2:0<br><strong>分析：</strong><br>&emsp;&emsp;根据main方法找到Single类，在准备阶段，Singleton类中的singleton，value1，value2分别为 null 0 0。<br>&emsp;&emsp;初始化阶段，先执行private static Singleton singleton = new Singleton()，这条语句触发了对象初始化方法，输出：普通方法块，构造方法，同时value1，value2都变成了1。<br>&emsp;&emsp;接下来两句public static int value1; public static int value2 = 0; value1未赋值，value2赋值后，初始化为0，<br>&emsp;&emsp;然后执行Singleton singleton = Singleton.getInstance()，输出：getInstance方法<br>&emsp;&emsp;最后输出：Singleton value1:1  Singleton value2:0</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述java类加载机制</title>
      <link href="/2019/08/04/%E7%AE%80%E8%BF%B0%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/04/%E7%AE%80%E8%BF%B0%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在面试中常会看到关于Java类加载机制的题目，今天特地整理了下加载机制的资料。</p><p>&emsp;&emsp;所谓的类加载机制就是JVM使用类加载器将编译生成的Class文件动态加载到JVM的内存空间中，最终形成可以被JVM使用的Java类型。JVM执行class字节码的过程可以分为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)这些阶段。其中验证、准备、解析3个部分统称为链接（Linking）。</p><h2 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h2><p>加载就是将class文件读入内存，并为之创建一个java.lang.Class对象，系统中所有的类都是java.lang.Class的实例。<br>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。<br>该阶段JVM完成三件事：</p><ol><li>通过来获取其定义的二进制字节流；</li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。如果这个类出错，但是应用程序没有调用这个类， JVM也不会报错。</p><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h2><p>验证的主要作用就是确保被加载的类的正确性。主要是完成四个阶段的验证：</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。例如：类是否有父类、是否继承了不允许被继承的类。</li><li>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正常执行。</li></ol><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>在准备阶段，JVM 会为类变量（static修饰的变量，并没有对实例变量进行内存分配，实例变量将会在对象实例化时随着对象一起分配在JAVA堆中）分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>如：public static int age = 20; 这里age为0，而不是20。但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。<br>如：public static final int age = 20; 这里age便是20，因为final修饰的变量赋值后不可更改，所以初始化就要给用户定义的值。</p><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>是虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化： "></a>初始化： </h2><p>在初始化阶段，主要为类的静态变量赋予正确的初始值, 在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值<br>JVM初始化步骤：</li><li>这个类还没有被加载和连接，则程序先加载并连接该类;</li><li>该类的直接父类还没有被初始化，则先初始化其直接父类;</li><li>类中有初始化语句，则系统依次执行这些初始化语句;</li></ol><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：  </p><ol><li>创建类的实例时（new、反射、反序列化）;</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值;</li><li>调用类的静态方法;</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）;</li><li>初始化某个类的子类，则这个父类先被初始化;</li><li>Java虚拟机启动时被标明为启动类的类（包含main()方法的那个类），直接使用 java.exe命令来运行某个主类;</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类。 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p><p> JVM预定义有三种类加载器:</p><ol><li>根类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>扩展类加载器（Extension ClassLoader）：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li><li>应用程序类加载器（ApplicationClassLoader）：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。</li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>JVM的类加载机制主要有如下3种。</p><ol><li><p>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p></li><li><p>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</p></li><li><p>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p><p><strong>双亲委派机制的优势：</strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2019/07/15/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E8%A6%81%E8%AF%B4%E7%82%B9%E5%95%A5/"/>
      <url>/2019/07/15/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E8%A6%81%E8%AF%B4%E7%82%B9%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<p>在CSDN,博客园写了一些博客后，最终还是搞了一个自己的博客，从今以后开始记录自己生活的点点滴滴。可以记录自己工作学习中绕过的弯，踩过的坑；可以记录自己身边好玩、有趣的事；甚至可以没事写点小说。博客就像自种田，三分自留地，中出新天地。默默耕耘，等待收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
