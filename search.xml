<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关键字static</title>
      <link href="/2019/08/12/%E5%85%B3%E9%94%AE%E5%AD%97static/"/>
      <url>/2019/08/12/%E5%85%B3%E9%94%AE%E5%AD%97static/</url>
      
        <content type="html"><![CDATA[<p>static: 可以修饰变量，方法，静态块，静态内部类，静态导包</p><p>静态变量：类变量，即该变量属于类本身，所有实例对象共享，可通过 类.变量 的方式直接获取，无需创建实例对象。<br>静态方法：该方法属于类本身，也不需要实例对象就可获取，所有实例对象共享。<br>静态代码块：属于类本身，类加载时初始。<br>静态内部类：static修饰类只有静态内部类这种情况，<br>静态导包：这个是JDK1.5之后的新特性，import static这两个关键字连用可以指定导入某个类中的指定静态资源。<br>注意：因为类加载机制的原因，静态方法不能访问非静态资源，因为静态方法在类加载时初始化，而非静态资源则是在创建对象实例时才初始化，这个顺序导致静态方法不能访问非静态资源，而非静态则可以调用静态的。</p><p>下面来个例子：</p><pre><code>import static java.lang.System.out;public class StaticDemo {    //成员变量    private String name;    //静态变量    private static int age = 25;    public static void getField(){        System.out.println(&quot;age:&quot; + age);        //静态方法中用成员变量会报：不能调用非静态属性的        //System.out.println(&quot;name:&quot; + name);    }    static {        System.out.println(&quot;静态代码块&quot;);    }    static class internalClass{        public void show(){            System.out.println(&quot;静态内部类方法 show&quot;);        }    }    public static void main(String [] args){        //因为已经静态导包，所以可以这样用        out.println(123);        System.out.println(&quot;类.静态变量方式调用：&quot;+ StaticDemo.age);        System.out.println(&quot;类.静态方法方式调用：&quot;);        StaticDemo.getField();        StaticDemo.internalClass obj = new internalClass();        System.out.println(&quot;内部类show方法：&quot;);        obj.show();    }}</code></pre><p>输出：<br>静态代码块<br>123<br>类.静态变量方式调用：25<br>类.静态方法方式调用：<br>age:25<br>内部类show方法：<br>静态内部类方法 show</p><p>ps：<a href="https://glamourchick.github.io/2019/08/04/%E7%AE%80%E8%BF%B0%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">有点懵的话可以看类加载机制那节哦^v^</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2019/08/11/ArrayList%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
      <url>/2019/08/11/ArrayList%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ArrayList是一个动态数组，非线程安全。</p><p>public class ArrayList<e> extends AbstractList<e> implements List<e>, RandomAccess, Cloneable, java.io.Serializable</e></e></e></p><p><strong>继承AbstractList：</strong></p><p><strong>实现List接口：</strong><br>支持集合的一般操作。提供了相关的添加、删除、修改、遍历等功能。这里有个有意思的地方：AbstractList实现了List, ArrayList却又去实现了List接口。这是作者Josh Bloch犯的mistake， 他写代码的时候觉得这个会有用处，其实没什么用，但因为没什么影响，就一直留到了现在。</p><p><strong>实现RandomAccess接口：</strong><br>RandomAccess只是个标识接口（Marker interface），<br>public interface RandomAccess {<br>}<br>就这样，里面啥也么有，表明支持快速随机访问。实现了该接口的话，那么用普通的for循环来遍历，性能更高。而没有实现该接口的话，使用Iterator来迭代，性能更高。<br>Collections的binarySearch方法中，可以看到</p><p> public static <t><br>    int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {<br>        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>            return Collections.indexedBinarySearch(list, key);<br>        else<br>            return Collections.iteratorBinarySearch(list, key);<br>    }</t></p><p><strong>实现Cloneable、Serializable接口：</strong> 支持克隆和序列化。</p><p><strong>属性：</strong><br>//默认初始容量为10<br>private static final int DEFAULT_CAPACITY = 10;</p><p>//空对象数组<br>private static final Object[] EMPTY_ELEMENTDATA = {};</p><p>//默认容量的空对象数组<br>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</p><p>//存放数据的数组， transient关键字标记的成员变量不参与序列化过程<br>transient Object[] elementData;</p><p>//数组元素个数<br>private int size;</p><p>//最大数组容量，数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节<br>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</p><p>下面看下LinkedList的一些方法：</p><ol><li><a href="#f1">public ArrayList()</a></li><li><a href="#f2">public ArrayList(int initialCapacity)</a></li><li><a href="#f3">public ArrayList(Collection&lt;? extends E&gt; c)</a></li><li><a href="#f4">public boolean add(E e)</a></li><li><a href="#f5">public void add(int index, E element)</a></li><li><a href="#f6">public E remove(int index)</a></li><li><a href="#f7">public boolean remove(Object o)</a></li><li><a href="#f8">public E set(int index, E element)</a></li><li><a href="#f9">public E get(int index)</a></li><li><a href="#f10">public void trimToSize()</a></li><li><a href="#f11">public int size()</a></li><li><a href="#f12">public boolean isEmpty()</a></li><li><a href="#f13">public boolean contains(Object o)</a></li><li><a href="#f14">public int indexOf(Object o)</a></li><li><a href="#f15">public int lastIndexOf(Object o)</a></li><li><a href="#f16">public void clear()</a></li><li><a href="#f17">public boolean addAll(Collection&lt;? extends E&gt; c)</a></li><li><a href="#f18">public boolean addAll(int index, Collection&lt;? extends E&gt; c)</a></li><li><a href="#f19">public boolean removeAll(Collection&lt;?&gt; c)</a></li><li><a href="#f20">public boolean retainAll(Collection&lt;?&gt; c)</a></li><li><a href="#f21">public List<e> subList(int fromIndex, int toIndex)</e></a></li><li><a href="#f22">public void forEach(Consumer&lt;? super E&gt; action)</a></li></ol><p><strong>构造函数：</strong><br><span id="f1"></span></p><pre><code>//构造一个初始容量为10的空list。当前只设置为空数组，还未设置容量。第一次add时，容量变成初始容量10    public ArrayList() {    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}</code></pre><p><span id="f2"></span></p><pre><code>//构造一个初始大小为initialCapacity的listpublic ArrayList(int initialCapacity) {    //参数大于0，则初始elementData为对应大小    //参数等于0，则初始elementData为空数组    //小于0 抛异常    if (initialCapacity &gt; 0) {        this.elementData = new Object[initialCapacity];    } else if (initialCapacity == 0) {        this.elementData = EMPTY_ELEMENTDATA;    } else {        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    }}</code></pre><p><span id="f3"></span></p><pre><code>//以集合c 初始化elementDatapublic ArrayList(Collection&lt;? extends E&gt; c) {    //集合c转换为数组，赋给elementData    elementData = c.toArray();    //如果elementData中有值，则检查c.toArray返回的是不是Object数组，不是的话就重新拷贝成Object[]    if ((size = elementData.length) != 0) {        // c.toArray might (incorrectly) not return Object[] (see 6260652)        if (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);// 以elementData为原数组，复制为size大小的 Object数组    } else {        // 若elementData中无值，则设为空数组        this.elementData = EMPTY_ELEMENTDATA;    }}</code></pre><p><span id="f4"></span></p><pre><code>//增加元素，public boolean add(E e) {    // 要在原size个基础上，再增加一个元素，需要确保当前容量足够    ensureCapacityInternal(size + 1);      elementData[size++] = e;// 添加元素到数组    return true;}</code></pre><p><span id="f5"></span></p><pre><code>//根据索引进行插入public void add(int index, E element) {    rangeCheckForAdd(index);//    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 参数意思依次为：原数组，拷贝原数组起始位置，目标数组，目标数组插入位置，要copy的长度    // System.arraycopy 是浅拷贝，内容相同，地址不变。Arrays.copyOf是深拷贝，拷贝出的是个内容相同的新对象。Arrays.copyOf中也调用了System.arraycopy    System.arraycopy(elementData, index, elementData, index + 1, size - index);    elementData[index] = element;    size++;}//判断位置是否合法private void rangeCheckForAdd(int index) {    if (index &gt; size || index &lt; 0)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}//扩容方法，如果elementData是默认容量数组，则最小扩容是10，否则为0public void ensureCapacity(int minCapacity) {    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)? 0 : DEFAULT_CAPACITY;    if (minCapacity &gt; minExpand) {        ensureExplicitCapacity(minCapacity);    }}//minCapacity表示当前数组能存储数据需要满足的最小容量private void ensureCapacityInternal(int minCapacity) {    //如果是默认容量空数组，则最小容量在 minCapacity和DEFAULT_CAPACITY中选最大的，    //即参数minCapacity &lt;= 10，则扩容为10，否则设为 minCapacity，    //所以调用无参构造函数，添加一个元素后，数组的容量为10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // 表示，最小容量大于当前数组的大小时，需要扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}private void grow(int minCapacity) {    int oldCapacity = elementData.length;    //新的容量 = 1.5倍的旧容量，这边用了右位移，性能更好    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //如果容量增加了一半还不满足，则直接扩容到所需的容量    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    //如果新的容量超过最大数组大小，则新容量设置为    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) {    //这边也挺有意思，int类型最大值为Integer.MAX_VALUE，这个最大值再+1就会 变为负数，它比0小，但它减最大值，可以能得到1，下面例子：    //int a =  Integer.MAX_VALUE;    //int b = a + 1;    //System.out.println(a); 输出 2147483647    //System.out.println(b); 输出 -2147483648    //System.out.println(b &gt; a); 输出 false    //System.out.println(b-a); 输出 1    //System.out.println(b&lt;0); 输出 true    // 所以如果比Integer.MAX_VALUE大，抛OOM    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    //如果比MAX_ARRAY_SIZE（即Integer.MAX_VALUE-8）大，则设置为Integer.MAX_VALUE，否则设置为MAX_ARRAY_SIZE    return (minCapacity &gt; MAX_ARRAY_SIZE) ?Integer.MAX_VALUE : MAX_ARRAY_SIZE;}</code></pre><p><span id="f6"></span></p><pre><code>//删除某个位置的元素，并返回被删除的值public E remove(int index) {    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    //需要移动的元素数量    int numMoved = size - index - 1;    if (numMoved &gt; 0)        //原数组index之后的元素向前挪        System.arraycopy(elementData, index+1, elementData, index, numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}</code></pre><p><span id="f7"></span></p><pre><code>// 删除元素，移除则返回truepublic boolean remove(Object o) {    if (o == null) {        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) {                fastRemove(index);                return true;            }    } else {        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}// 检验index合法性 private void rangeCheck(int index) {    if (index &gt;= size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}//快速移除，或说remove(int index)中为什么不直接调用此方法呢 private void fastRemove(int index) {    modCount++;    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work}</code></pre><p><span id="f8"></span></p><pre><code>//更改值，返回原值public E set(int index, E element) {    rangeCheck(index);    E oldValue = elementData(index);    elementData[index] = element;    return oldValue;}</code></pre><p><span id="f9"></span></p><pre><code>//查询index位置的值public E get(int index) {    rangeCheck(index);    return elementData(index);}</code></pre><p><span id="f10"></span></p><pre><code>//将容量设为当前元素实际个数， 节约存储空间public void trimToSize() {    modCount++;    if (size &lt; elementData.length) {        elementData = (size == 0)          ? EMPTY_ELEMENTDATA          : Arrays.copyOf(elementData, size);    }}</code></pre><p><span id="f11"></span></p><pre><code>//返回集合大小public int size() {    return size;}</code></pre><p><span id="f12"></span></p><pre><code>//判断是否为空数组public boolean isEmpty() {    return size == 0;}</code></pre><p><span id="f13"></span></p><pre><code>//判断是否包含某个元素public boolean contains(Object o) {    return indexOf(o) &gt;= 0;}</code></pre><p><span id="f14"></span></p><pre><code>//根据索引查询元素，查不到则返回-1public int indexOf(Object o) {    if (o == null) {        for (int i = 0; i &lt; size; i++)            if (elementData[i]==null)                return i;    } else {        for (int i = 0; i &lt; size; i++)            if (o.equals(elementData[i]))                return i;    }    return -1;}</code></pre><p><span id="f15"></span></p><pre><code>//也是根据索引查询元素，不过是从后往前查public int lastIndexOf(Object o) {    if (o == null) {        for (int i = size-1; i &gt;= 0; i--)            if (elementData[i]==null)                return i;    } else {        for (int i = size-1; i &gt;= 0; i--)            if (o.equals(elementData[i]))                return i;    }    return -1;}</code></pre><p><span id="f16"></span></p><pre><code>// 清空集合public void clear() {    modCount++;    // clear to let GC do its work    for (int i = 0; i &lt; size; i++)        elementData[i] = null;    size = 0;}</code></pre><p><span id="f17"></span></p><pre><code>//向arrayList中添加集合，还是通过arraycopy来实现public boolean addAll(Collection&lt;? extends E&gt; c) {    Object[] a = c.toArray();    int numNew = a.length;    ensureCapacityInternal(size + numNew);  // Increments modCount    System.arraycopy(a, 0, elementData, size, numNew);    size += numNew;    return numNew != 0;}</code></pre><p><span id="f18"></span></p><pre><code>//在index位置向arrayList中添加集合public boolean addAll(int index, Collection&lt;? extends E&gt; c) {    rangeCheckForAdd(index);    Object[] a = c.toArray();    int numNew = a.length;    ensureCapacityInternal(size + numNew);  // Increments modCount    int numMoved = size - index;    //将原arrayList的index后面的数据放到 index+numNew后，为要插入的集合腾出位置    if (numMoved &gt; 0)        System.arraycopy(elementData, index, elementData, index + numNew,                         numMoved);    System.arraycopy(a, 0, elementData, index, numNew);    size += numNew;    return numNew != 0;} //移除fromIndex到toIndex之间的元素 protected void removeRange(int fromIndex, int toIndex) {    modCount++;    int numMoved = size - toIndex;    // 原toIndex后的数据挪到fromIndex后面    System.arraycopy(elementData, toIndex, elementData, fromIndex,                     numMoved);    // 计算新的size，size之后的元素设为null    int newSize = size - (toIndex-fromIndex);    for (int i = newSize; i &lt; size; i++) {        elementData[i] = null;    }    size = newSize;}</code></pre><p><span id="f19"></span></p><pre><code>//从arraylist中移除所有参数集合c所包含的元素public boolean removeAll(Collection&lt;?&gt; c) {    Objects.requireNonNull(c);    return batchRemove(c, false);}</code></pre><p><span id="f20"></span>    </p><pre><code>//保留arraylist中所有参数集合c所包含的元素public boolean retainAll(Collection&lt;?&gt; c) {    Objects.requireNonNull(c);    return batchRemove(c, true);}//校验参数是否为nullpublic static &lt;T&gt; T requireNonNull(T obj) {    if (obj == null)        throw new NullPointerException();    return obj;}//批量移除, 有移除操作返回trueprivate boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {    final Object[] elementData = this.elementData;    int r = 0, w = 0;//r用于arrayList的循环，w用于向 final Object[] elementData添加元素    boolean modified = false;    try {        for (; r &lt; size; r++)            //complement作为标识，控制向final Object[] elementData添加 c包含的还是不包含的元素            if (c.contains(elementData[r]) == complement)                elementData[w++] = elementData[r];    } finally {        // 如果r未循环到size的话，就将原数组r之后的元素从w位置开始赋给final Object[] elementData        if (r != size) {            System.arraycopy(elementData, r, elementData, w, size - r);            w += size - r;        }        // w之后的元素设置为null，大小设置为w        if (w != size) {            for (int i = w; i &lt; size; i++)                elementData[i] = null;            modCount += size - w;            size = w;            modified = true;        }    }    return modified;}</code></pre><p><span id="f21"></span></p><pre><code>// 截取fromIndex 到toIndex之间的元素public List&lt;E&gt; subList(int fromIndex, int toIndex) {    subListRangeCheck(fromIndex, toIndex, size);//范围校验    return new SubList(this, 0, fromIndex, toIndex);//arrayList中维护一个SubList类，其继承AbstractList，实现RandomAccess}static void subListRangeCheck(int fromIndex, int toIndex, int size) {    if (fromIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);    if (toIndex &gt; size)        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);    if (fromIndex &gt; toIndex)        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +                                           &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);}</code></pre><p><span id="f22"></span></p><pre><code>// 遍历数组，JAVA8之后，Iterable接口新增了一个forEach，因为arrayList实现List接口，Iterable是List的祖先，所以List可以调用这个方法，// forEach的参数为Consumer&lt;? super E&gt; action, Consumer接口中只有void accept(T t)方法，//所以为函数式接口（接口中只定义一个抽象方法，可以有多个非抽象方法的接口，以FunctionalInterface注解修饰），可以用Lambda表达式实现@Overridepublic void forEach(Consumer&lt;? super E&gt; action) {    Objects.requireNonNull(action);    final int expectedModCount = modCount;    @SuppressWarnings(&quot;unchecked&quot;)    final E[] elementData = (E[]) this.elementData;    final int size = this.size;    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {        action.accept(elementData[i]);    }    //for()中add/remove不报错，用forEach（）则会报错java.util.ConcurrentModificationException，就是因为expectedModCount和modCount的判断    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ArrayList 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码简析</title>
      <link href="/2019/08/07/Linkedlist%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
      <url>/2019/08/07/Linkedlist%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>LinkedList是基于链表的数据结构，非线程安全。</p><p>public class LinkedList<e> extends AbstractSequentialList<e> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p><p><strong>继承：</strong><br>&emsp;&emsp;LinkedList 继承了AbstractSequentialList, 而AbstractSequentialList继承了AbstractList（ArrayList也继承它）, AbstractList支持随机访问, 可以随意访问该数据结构中的任意一个节点, 如vector可以通过[]操作符, 直接访问[n], 不需要遍历其他的节点。<br>但是AbstractSequentialList仅支持按次序访问,要想访问第n个元素, 只能从第一个开始,一个节点一个节点的往下找, 因而随机访问效率低。</p><p><strong>接口：</strong><br>&emsp;&emsp;实现List接口：支持集合的一般操作。提供了相关的添加、删除、修改、遍历等功能。<br>&emsp;&emsp;实现Deque （Double ended queue）接口： 可用作队列或双端队列<br>&emsp;&emsp;实现Cloneable、Serializable接口：支持克隆和序列化。</p><p>LinkedList底层维护着双向链表, 每个结点都有一个前驱和后继结点：<br>    private static class Node<e> {</e></p><pre><code>    E item; // 存储节点值    Node&lt;E&gt; next; // 后继, 指向下一个节点    Node&lt;E&gt; prev; // 前驱, 指向前一个节点    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}</code></pre><p><strong>LinkedList的成员变量：</strong><br> transient int size = 0; // LinkedList节点个数<br> transient Node<e> first;//头元素<br> transient Node<e> last;// 尾元素</e></e></p><p><strong>LinkedList的两种构造函数：</strong></p><pre><code>// 无参构造  public LinkedList() {} public LinkedList(Collection&lt;? extends E&gt; c) {    this();// 调用无参构造函数    addAll(c);// 添加集合中所有的元素}</code></pre><p>下面看下LinkedList的一些方法：</p><ol><li><a href="#f1">private void linkFirst(E e)// 表头添加元素</a></li><li><a href="#f2">void linkLast(E e)// 表尾添加元素</a></li><li><a href="#f3">public void addFirst(E e)// 调用linkFirst</a></li><li><a href="#f4">public void addLast(E e)// 调用linkLast</a></li><li><a href="#f5">void linkBefore(E e, Node<e> succ)// 在非空节点succ前插入节点e</e></a></li><li><a href="#f6">private E unlinkFirst(Node<e> f)//释放非空的首节点f, 并返回值</e></a></li><li><a href="#f7">private E unlinkLast(Node<e> l)// 释放非空的尾节点l, 并返回值</e></a></li><li><a href="#f8">public E removeFirst()// 从链表中移除头结点并返回其值</a></li><li><a href="#f9">public E removeLast()// 从链表中移除尾结点并返回其值</a></li><li><a href="#f10">E unlink(Node<e> x)// 释放非空节点x</e></a></li><li><a href="#f11">public E getFirst()//返回链表中的头结点的值</a></li><li><a href="#f12">public E getLast()//返回链表中尾结点的值, 和上面的类似</a></li><li><a href="#f13">public int indexOf(Object o)//返回链表中参数第一次出现的索引位置, 没有就返回-1</a></li><li><a href="#f14">public boolean contains(Object o)// 判断链表是否包含参数, 包含为true</a></li><li><a href="#f15">public E remove(int index)//根据索引进行删除</a></li><li><a href="#f16">public boolean remove(Object o)//从列表中移除指定元素的第一个匹配项并返回true, 如果列表不包含该参数, 列表不变, 返回false</a></li><li><a href="#f17">public boolean addAll(Collection&lt;? extends E&gt; c)// addAll有两种方法, 一个传index,一个不传</a></li><li><a href="#f18">public boolean addAll(int index, Collection&lt;? extends E&gt; c)</a></li><li><a href="#f19">public void clear()//所有表中所有元素, 此列表为空</a></li><li><a href="#f20">Node<e> node(int index)//返回指点索引的非空节点</e></a></li><li><a href="#f21">public E get(int index)//返回指定索引节点的值</a></li><li><a href="#f22">public E set(int index, E element)//替换指定位置节点的值, 返回旧值</a></li><li><a href="#f23">public void add(int index, E element)// 指定位置新增节点</a></li><li><a href="#f24">public E peek()// 获取头节点的值</a></li><li><a href="#f25">public E poll()// 获取头节点的值, 同时删除该头节点</a></li><li><a href="#f26">public void push(E e)//入栈</a></li><li><a href="#f27">public E pop()//出栈</a></li><li><a href="#f28">public Object[] toArray() //转为数组</a></li><li><a href="#f29">public <t> T[] toArray(T[] a)//转为数组, 传入T类型的数组, 返回T类型的数组</t></a></li></ol><p>// <span id="f1">表头添加元素</span><br>private void linkFirst(E e) {</p><pre><code>final Node&lt;E&gt; f = first;// 用一个常量存储旧的头结点final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);// 新建一个节点,节点值参数e,后继为旧的头节点first = newNode;// 设置newNode为新的头节点if (f == null)    last = newNode;// 如果newNode后面没有节点就将newNode作为最后一个节点else    f.prev = newNode;// 否则将旧的头节点前驱设置为newModesize++;// 长度增加modCount++;</code></pre><p>}</p><p>// <span id="f2">表尾添加元素</span><br>void linkLast(E e) {</p><pre><code>final Node&lt;E&gt; l = last;// 用一个常量存储旧的尾结点final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 新建一个节点,节点值参数e,前驱为旧的尾节点last = newNode;// 设置newNode为新的尾节点if (l == null)    first = newNode;// 如果newNode前面没有节点就将newNode作为第一个节点else    l.next = newNode;// 否则旧的尾结点后继设置为newModesize++;// 长度增加modCount++;</code></pre><p>}</p><p>//<span id="f3">调用linkFirst</span><br>public void addFirst(E e) {<br>&emsp;&emsp;linkFirst(e);<br>}<br>//<span id="f4">调用linkLast</span><br>public void addLast(E e) {<br>&emsp;&emsp;linkLast(e);<br>}</p><p>// <span id="f5">在非空节点succ前插入节点e</span><br>void linkBefore(E e, Node<e> succ) {</e></p><pre><code>final Node&lt;E&gt; pred = succ.prev;// 常量pred 存储 succ的前驱final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);// 新建node, 前驱为pred, 后继为succ, 值为esucc.prev = newNode;// 将succ的前驱设置为newNodeif (pred == null)    first = newNode;// 如果pred为null,则表明原succ为头节点, 设置newNoode为头节点else    pred.next = newNode;// 否则设置pred的后继为newNodesize++;// 长度增加modCount++;</code></pre><p>}</p><p>//<span id="f6">释放非空的首节点f, 并返回值</span><br>private E unlinkFirst(Node<e> f) {</e></p><pre><code>final E element = f.item;// 常量element存f的值final Node&lt;E&gt; next = f.next;// 常量节点next 存f的后继f.item = null;// f节点的值设置为nullf.next = null;// 切断f与后继节点的关联first = next;// 头节点改为f的后继节点if (next == null)    last = null;//如果f后继节点为null,说明该表只有一个元素, f既是头节点, 也是尾结点, f将要被移除, 所以last也要设置为nullelse    next.prev = null;//否则, 将新的头节点前驱设置为nullsize--;modCount++;return element;// 返回被释放的节点的值</code></pre><p>}</p><p>// <span id="f7">释放非空的尾节点l, 并返回值</span><br>private E unlinkLast(Node<e> l) {</e></p><pre><code>final E element = l.item;// 常量element存l的值final Node&lt;E&gt; prev = l.prev;// 常量节点prev 存l的前驱l.item = null;// 清除l节点的值l.prev = null; // 切断l与前驱节点的关联last = prev;// 尾节点改为l的前驱节点if (prev == null)    first = null;//如果l前驱节点为null, 说明该表只有一个元素, l既是头节点, 也是尾结点, l将要被移除, 所以last也要设置为nullelse    prev.next = null;//否则, 将新的尾节点后继设置为nullsize--;modCount++;return element;// 返回被释放的节点的值</code></pre><p>}</p><p>// <span id="f8">从链表中移除头结点并返回其值</span><br>public E removeFirst() {</p><pre><code>final Node&lt;E&gt; f = first;if (f == null)    throw new NoSuchElementException();return unlinkFirst(f);// 调用了unlinkFirst方法</code></pre><p>}<br>// <span id="f9">从链表中移除尾结点并返回其值</span><br>public E removeLast() {</p><pre><code>final Node&lt;E&gt; l = last;if (l == null)    throw new NoSuchElementException();return unlinkLast(l);</code></pre><p>}</p><p>// <span id="f10">释放非空节点x</span><br>E unlink(Node<e> x) {</e></p><pre><code>//保存 x的值、前驱、后继final E element = x.item;final Node&lt;E&gt; next = x.next;final Node&lt;E&gt; prev = x.prev; if (prev == null) {    first = next; // 如果x前驱为空, 则x为头结点, 设置x的下一个节点为first} else {    prev.next = next;// 否则设置x上一个节点的后继为x下一个节点    x.prev = null;// 并且设置x的前驱为null}if (next == null) {    last = prev;// 如果x后继为空, 则表明x为尾节点, 将x的前一个节点设置为last} else {    next.prev = prev;// 否则 x下一个节点的前驱设置为x的上一个节点    x.next = null;// 并把x的后继置null}//此时的x就是个孤家寡人, 它的前驱后继都为null, 它的上下节点进行了关联。接着再处理x的值x.item = null;// x的值置nullsize--;//链表长度减1modCount++;return element;// 返回删除的节点</code></pre><p>}</p><p>//<span id="f11">返回链表中的头结点的值</span><br>public E getFirst() {</p><pre><code>final Node&lt;E&gt; f = first;if (f == null)    throw new NoSuchElementException();//如果不存在, 则抛异常return f.item;</code></pre><p>}</p><p>//<span id="f12">返回链表中尾结点的值, 和上面的类似</span><br>public E getLast() {</p><pre><code>final Node&lt;E&gt; l = last;if (l == null)    throw new NoSuchElementException();return l.item;</code></pre><p>}</p><p>//<span id="f13">返回链表中参数第一次出现的索引位置, 没有就返回-1</span><br>public int indexOf(Object o) {</p><pre><code>int index = 0;//如果参数o为null,则返回值为null的节点的索引//o不为null, 则返回值与o相匹配的节点的索引// 如没匹配到则返回-1if (o == null) {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (x.item == null)            return index;        index++;    }} else {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (o.equals(x.item))            return index;        index++;    }}return -1;</code></pre><p>}<br>// <span id="f14">判断链表是否包含参数, 包含为true</span><br>public boolean contains(Object o) {<br>&emsp;&emsp;return indexOf(o) != -1;<br>}</p><p>//<span id="f15">根据索引进行删除</span><br>public E remove(int index) {</p><pre><code>checkElementIndex(index);return unlink(node(index));</code></pre><p>}<br>//<span id="f16">从列表中移除指定元素的第一个匹配项并返回true, 如果列表不包含该参数, 列表不变, 返回false</span><br>public boolean remove(Object o) {</p><pre><code>if (o == null) {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (x.item == null) {            unlink(x);            return true;        }    }} else {    for (Node&lt;E&gt; x = first; x != null; x = x.next) {        if (o.equals(x.item)) {            unlink(x);            return true;        }    }}return false;</code></pre><p>}<br>// <span id="f17">addAll有两种方法, 一个传index,一个不传</span><br>public boolean addAll(Collection&lt;? extends E&gt; c) {<br>&emsp;&emsp;return addAll(size, c);<br>}<br><span id="f18">不传index</span><br>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {</p><pre><code>checkPositionIndex(index);// 判断index是否越界, 越界则抛出异常, 0 &lt;= index &lt;= sizeObject[] a = c.toArray(); // 将集合参数c转为数组int numNew = a.length;// 获取其长度if (numNew == 0)    return false;//如果传进来的数组没有值, 则返回falseNode&lt;E&gt; pred, succ; //新建前驱后继节点, 前驱：precursor,后继: succeedif (index == size) {//若在表尾添加,则前驱为原尾结点, 后继为null    succ = null;    pred = last;} else { //否则, 前驱为index上一个节点,后继为index节点    succ = node(index);    pred = succ.prev;}//循环插入参数集合元素for (Object o : a) {    @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;    //新建一个有前驱和值的节点, 此时newNode的前一个节点确定了, 但是newNode前一个节点还未设置后继    Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);    if (pred == null)        first = newNode;// 前驱pred为null, 表明在头节点前插入, 设置newNode为新的头节点    else        pred.next = newNode;//否则设置pred的后继为当前节点, 即newNode前一个节点设置了后继    pred = newNode;//newNode作为下一个节点的前驱}//在经过上面的循环后, 此时pred=newNode, 参数集合的头部已经连接进原链表中, 但是尾部还没有连接进原链表中if (succ == null) {    last = pred;// 如果在表尾插入, 则设置newNode为尾结点} else {//否则 newNode的后继设置为succ, 并吧succ的前驱设置为newNode,这样参数集合的尾部也连接进原链表中    pred.next = succ;    succ.prev = pred;}size += numNew;//长度增加 numNewmodCount++;return true;</code></pre><p>}</p><p>//<span id="f19">所有表中所有元素, 此列表为空</span><br>public void clear() {</p><pre><code>//从first节点开始, 依次清空每个节点。//x不在for()中设置为next,而是在循环体中设置为next,是因为方法体执行完后, x.next=null了for (Node&lt;E&gt; x = first; x != null; ) {    Node&lt;E&gt; next = x.next;    x.item = null;    x.next = null;    x.prev = null;    x = next; }//头尾节点设置为nullfirst = last = null;size = 0;modCount++;</code></pre><p>}<br>//<span id="f20">返回指点索引的非空节点</span><br>Node<e> node(int index) {</e></p><pre><code>//此处查询进行了优化, 每次只要查询列表的一半//size右移1位, 变为size的一半, 在列表的前半段查询if (index &lt; (size &gt;&gt; 1)) {    Node&lt;E&gt; x = first;    for (int i = 0; i &lt; index; i++)        x = x.next;    return x;} else {//在列表的后半段查询    Node&lt;E&gt; x = last;    for (int i = size - 1; i &gt; index; i--)        x = x.prev;    return x;}</code></pre><p>}<br>//<span id="f21">返回指定索引节点的值</span><br>public E get(int index) {</p><pre><code>checkElementIndex(index);//判断index是否越界, 越界则抛出异常, 0 &lt;= index &lt; sizereturn node(index).item;</code></pre><p>}</p><p>//<span id="f22">替换指定位置节点的值, 返回旧值</span><br>public E set(int index, E element) {</p><pre><code>checkElementIndex(index);Node&lt;E&gt; x = node(index);//获取index位置的节点E oldVal = x.item;x.item = element;//值更替return oldVal;</code></pre><p>}<br>// <span id="f23">指定位置新增节点</span><br>public void add(int index, E element) {</p><pre><code>checkPositionIndex(index);if (index == size)//在表尾添加    linkLast(element);else    linkBefore(element, node(index));//在index节点前添加</code></pre><p>}<br>// <span id="f24">获取头节点的值</span><br>public E peek() {</p><pre><code>final Node&lt;E&gt; f = first;return (f == null) ? null : f.item;</code></pre><p>}<br>// <span id="f25">获取头节点的值, 同时删除该头节点</span><br>public E poll() {</p><pre><code>final Node&lt;E&gt; f = first;return (f == null) ? null : unlinkFirst(f);</code></pre><p>}<br>//<span id="f26">入栈</span><br>public void push(E e) {<br>&emsp;&emsp;addFirst(e);<br>}<br>//<span id="f27">出栈</span><br>public E pop() {<br>&emsp;&emsp;return removeFirst();<br>}<br>//<span id="f28">转为数组, 就是新建个数组, 然后把链表中值一个个加到数组中, 返回的是Object类型数组</span><br>public Object[] toArray() {</p><pre><code>Object[] result = new Object[size];int i = 0;for (Node&lt;E&gt; x = first; x != null; x = x.next)    result[i++] = x.item;return result;</code></pre><p>}<br>//<span id="f29">转为数组, 传入T类型的数组, 返回T类型的数组</span><br>public <t> T[] toArray(T[] a) {</t></p><pre><code>// 如果传入的a比链表小, 则反射生成一个和链表一样大的数组if (a.length &lt; size)    a = (T[])java.lang.reflect.Array.newInstance(                        a.getClass().getComponentType(), size);int i = 0;Object[] result = a;for (Node&lt;E&gt; x = first; x != null; x = x.next)    result[i++] = x.item;//如果数组比链表大, 则a[size]设为null, a[size]后的值不变if (a.length &gt; size)    a[size] = null;return a;</code></pre><p>}</p><p>linkedList中维护一个ListItr类, 这个类实现了ListIterator, 通过new LinkedList.listIterator()<br>或new LinkedList.listIterator(int index)来获取ListIterator迭代器,这里就不再讲了。</p><p>网上有人对LinkedList和ArrayList进行了一些实验, 比较它们不同操作下的性能, 大家可以看一看：<br><a href="https://blog.csdn.net/u011676300/article/details/80440774" target="_blank" rel="noopener">https://blog.csdn.net/u011676300/article/details/80440774</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java  linkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制习题</title>
      <link href="/2019/08/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%A0%E9%A2%98/"/>
      <url>/2019/08/05/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在了解了类加载机制后，我们来点真格的！</p><h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><p>  public class  Father{</p><pre><code>static { System.out.println(&quot;Father静态代码块&quot;);}   { System.out.println(&quot;Father普通代码块&quot;); }   public Father() {       System.out.println(&quot;father 的构造函数&quot;);   }</code></pre><p>  }</p><p>  class Son extends  Father{</p><pre><code>static { System.out.println(&quot;son 静态代码块&quot;);}   { System.out.println(&quot;son 代码块&quot;); }   public Son() {      System.out.println(&quot;son 的构造函数&quot;);   }   public static void main(String[] args) {       System.out.println(&quot;son 的main方法&quot;);       new Son();   }</code></pre><p>  }</p><p><strong>输出结果：</strong><br>Father静态代码块<br>son 静态代码块<br>son 的main方法<br>Father普通代码块<br>father 的构造函数<br>son 代码块<br>son 的构造函数<br><strong>分析：</strong><br>&emsp;&emsp;实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有类初始化方法和对象初始化方法。<br>类初始化方法：编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。<br>对象初始化方法：编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</p><p>（我直接把上章的粘在这）<br>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：  </p><ol><li>创建类的实例时（new、反射、反序列化）;</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值;</li><li>调用类的静态方法;</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）;</li><li>初始化某个类的子类，则这个父类先被初始化;</li><li>Java虚拟机启动时被标明为启动类的类（包含main()方法的那个类），直接使用 java.exe命令来运行某个主类;</li></ol><p>&emsp;&emsp;首先，初始化有main方法的主类，即Son类，Son的父类还未初始化，所以先初始化Father类，输出：Father静态代码块和son 静态代码块。<br>&emsp;&emsp;然后，执行main方法中的输出：son 的main方法。<br>&emsp;&emsp;接着到了new Son()，进行对象初始化。还是先输出Father的对象初始化方法，按顺序为：Father普通代码块  father 的构造函数，接着输出Son的： son 代码块  son 的构造函数  </p><h3 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h3><p>  class Singleton{</p><pre><code>private static Singleton singleton = new Singleton();public static int value1;public static int value2 = 0;  static{ System.out.println(&quot;静态方法块&quot;);} private Singleton(){    value1++;    value2++;    System.out.println(&quot;构造方法&quot;);}{ System.out.println(&quot;普通方法块&quot;); }    public static Singleton getInstance(){       System.out.println(&quot;getInstance方法&quot;);       return singleton;   }   public static void main(String[] args) {       Singleton singleton = Singleton.getInstance();       System.out.println(&quot;Singleton value1:&quot; + singleton.value1);       System.out.println(&quot;Singleton value2:&quot; + singleton.value2);   }</code></pre><p>  }<br><strong>输出结果：</strong><br>普通方法块<br>构造方法<br>静态方法块<br>getInstance方法<br>Singleton value1:1<br>Singleton value2:0<br><strong>分析：</strong><br>&emsp;&emsp;根据main方法找到Single类，在准备阶段，Singleton类中的singleton，value1，value2分别为 null 0 0。<br>&emsp;&emsp;初始化阶段，先执行private static Singleton singleton = new Singleton()，这条语句触发了对象初始化方法，输出：普通方法块，构造方法，同时value1，value2都变成了1。<br>&emsp;&emsp;接下来两句public static int value1; public static int value2 = 0; value1未赋值，value2赋值后，初始化为0，<br>&emsp;&emsp;然后执行Singleton singleton = Singleton.getInstance()，输出：getInstance方法<br>&emsp;&emsp;最后输出：Singleton value1:1  Singleton value2:0</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述java类加载机制</title>
      <link href="/2019/08/04/%E7%AE%80%E8%BF%B0%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/04/%E7%AE%80%E8%BF%B0%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在面试中常会看到关于Java类加载机制的题目，今天特地整理了下加载机制的资料。</p><p>&emsp;&emsp;所谓的类加载机制就是JVM使用类加载器将编译生成的Class文件动态加载到JVM的内存空间中，最终形成可以被JVM使用的Java类型。JVM执行class字节码的过程可以分为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)这些阶段。其中验证、准备、解析3个部分统称为链接（Linking）。</p><h2 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h2><p>加载就是将class文件读入内存，并为之创建一个java.lang.Class对象，系统中所有的类都是java.lang.Class的实例。<br>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。<br>该阶段JVM完成三件事：</p><ol><li>通过来获取其定义的二进制字节流；</li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。如果这个类出错，但是应用程序没有调用这个类， JVM也不会报错。</p><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h2><p>验证的主要作用就是确保被加载的类的正确性。主要是完成四个阶段的验证：</p><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。例如：类是否有父类、是否继承了不允许被继承的类。</li><li>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正常执行。</li></ol><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>在准备阶段，JVM 会为类变量（static修饰的变量，并没有对实例变量进行内存分配，实例变量将会在对象实例化时随着对象一起分配在JAVA堆中）分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。<br>如：public static int age = 20; 这里age为0，而不是20。但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。<br>如：public static final int age = 20; 这里age便是20，因为final修饰的变量赋值后不可更改，所以初始化就要给用户定义的值。</p><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p>是虚拟机将常量池内的符号引用替换为直接引用的过程</p><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化： "></a>初始化： </h2><p>在初始化阶段，主要为类的静态变量赋予正确的初始值, 在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值<br>JVM初始化步骤：</li><li>这个类还没有被加载和连接，则程序先加载并连接该类;</li><li>该类的直接父类还没有被初始化，则先初始化其直接父类;</li><li>类中有初始化语句，则系统依次执行这些初始化语句;</li></ol><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：  </p><ol><li>创建类的实例时（new、反射、反序列化）;</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值;</li><li>调用类的静态方法;</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）;</li><li>初始化某个类的子类，则这个父类先被初始化;</li><li>Java虚拟机启动时被标明为启动类的类（包含main()方法的那个类），直接使用 java.exe命令来运行某个主类;</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类。 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p><p> JVM预定义有三种类加载器:</p><ol><li>根类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>扩展类加载器（Extension ClassLoader）：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li><li>应用程序类加载器（ApplicationClassLoader）：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。</li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>JVM的类加载机制主要有如下3种。</p><ol><li><p>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p></li><li><p>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</p></li><li><p>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p><p><strong>双亲委派机制的优势：</strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2019/07/15/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E8%A6%81%E8%AF%B4%E7%82%B9%E5%95%A5/"/>
      <url>/2019/07/15/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E8%A6%81%E8%AF%B4%E7%82%B9%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<p>在CSDN,博客园写了一些博客后，最终还是搞了一个自己的博客，从今以后开始记录自己生活的点点滴滴。可以记录自己工作学习中绕过的弯，踩过的坑；可以记录自己身边好玩、有趣的事；甚至可以没事写点小说。博客就像自种田，三分自留地，中出新天地。默默耕耘，等待收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
